<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roster de Jugadores</title>
    <style>
        /* Fuentes de Google Fonts (opcionales, busca alternativas si no te gustan) */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300;400;600;700&family=Press+Start+2P&display=swap');

        /* Reseteo básico para ocupar toda la pantalla */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Evita barras de scroll */
        }

        body {
            font-family: 'Chakra Petch', sans-serif; /* Fuente más moderna y técnica */
            background-color: #0d0d0d; /* Fondo más oscuro */
            color: #e0e0e0;
        }

        #display-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            box-sizing: border-box;
            padding: 2rem 4rem; /* Más padding horizontal para centrar mejor el contenido visualmente */
            background: linear-gradient(135deg, #1f1f1f, #0d0d0d); /* Degradado sutil */
            position: relative; /* Para posibles elementos superpuestos */
        }

        #header-logo {
            flex-shrink: 0;
            text-align: center;
            margin-bottom: 2rem;
        }

        #header-logo img {
            max-height: 120px; /* Ajusta el tamaño del logo */
            width: auto;
            filter: drop-shadow(0 0 15px rgba(255, 204, 0, 0.7)); /* Sombra de neón amarilla */
        }

        #category-title {
            font-family: 'Chakra Petch', sans-serif; /* Usamos la misma fuente */
            font-size: 5rem; /* Más grande aún */
            font-weight: 700; /* Más robusto */
            color: #f6ab13; /* Rosa magenta vibrante */
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 0 0 5px rgba(255, 255, 255, 0.5); /* Sombra de neón */
            margin: 0;
            margin-bottom: 2rem; /* Más espacio abajo del título */
            text-align: center;
            flex-shrink: 0;
            transition: opacity 0.3s ease-in-out; /* Transición para el fade */
        }

        /* Estilos para los nuevos controles de búsqueda y filtro */
        #controls {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        #controls select,
        #controls input[type="text"] {
            font-family: 'Chakra Petch', sans-serif;
            font-size: 1.5rem;
            padding: 0.7rem 1rem;
            border-radius: 8px;
            border: 2px solid #ffd400;
            background-color: #1f1f1f;
            color: #e0e0e0;
            outline: none;
            box-shadow: 0 0 10px rgba(255, 212, 0, 0.2);
            flex-grow: 1;
            min-width: 200px;
        }

        #controls select:focus,
        #controls input[type="text"]:focus {
            border-color: #f6ab13;
        }
        #category-title.fade-out {
            opacity: 0;
        }

        #player-viewport {
            flex-grow: 1;
            overflow: hidden;
            overflow-y: auto; /* Permitir scroll vertical */
            position: relative;
            border-top: 3px solid #ffd400; /* Línea divisoria amarilla */
            border-bottom: 3px solid #ffd400; /* Línea divisoria amarilla */
            padding-top: 1rem; /* Espacio dentro del viewport */
            padding-bottom: 1rem;
        }

        #player-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #player-list.fade-out {
            opacity: 0;
        }
        
        #player-list li {
            font-family: 'Chakra Petch', sans-serif;
            font-size: 3.5rem;      /* Fuente más grande */
            line-height: 5rem;      /* Altura de línea más grande */
            height: 5rem;           /* Altura fija (debe coincidir con line-height) */
            
            color: #ffffff;
            white-space: nowrap; /* Mantener en una línea */
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2); /* Línea punteada sutil */
            padding-left: 1rem; /* Pequeño indentado */
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.3); /* Ligero resplandor blanco */
        }

        #player-list li:last-child {
            border-bottom: none;
        }

        /* Responsive: Ajustes para pantallas más pequeñas si fuera necesario */
        @media (max-width: 768px) {
            #display-container {
                padding: 1rem 2rem;
                padding-bottom: 2rem; /* Añadir espacio abajo */
            }
            #header-logo img {
                max-height: 80px;
            }
            #category-title {
                font-size: 2.5rem; /* Reducido para mejor ajuste */
                margin-bottom: 1rem;
            }
            /* Ajustes para el texto de la lista */
            #player-list li {
                font-size: 1.8rem; /* Reducimos un poco más la fuente */
                white-space: normal; /* Permitir que el texto se divida en varias líneas */
                height: auto; /* Altura automática para acomodar el texto */
                line-height: 1.4; /* Espaciado de línea normal */
                padding: 0.8rem 0; /* Espaciado vertical */
            }
        }
    </style>
</head>
<body>

    <div id="display-container">
        <div id="header-logo">
            <img src="fredyparty-logo.png" alt="Fredy Party Logo">
        </div>

        <div id="controls">
            <select id="category-filter"></select>
            <input type="text" id="search-input" placeholder="Buscar jugador...">
        </div>

        <h2 id="category-title">Cargando Roster...</h2>
        <div id="player-viewport">
            <ul id="player-list">
                </ul>
        </div>
    </div>

    <script>
        // Obtener el nombre del archivo de la URL, con un valor por defecto
        const urlParams = new URLSearchParams(window.location.search);
        const ROSTER_FILE_NAME = urlParams.get('file') || 'roster-latest.html';

        const categoryEl = document.getElementById('category-title');
        const viewportEl = document.getElementById('player-viewport');
        const playerListEl = document.getElementById('player-list');
        const categoryFilterEl = document.getElementById('category-filter');
        const searchInputEl = document.getElementById('search-input');

        let allPlayersData = {}; // Para almacenar todos los jugadores por categoría

        let rosterData = {};
        let categoryKeys = [];
        let currentCategoryIndex = 0;
        let currentPlayerIndex = 0;
        let liHeight = 0;
        let playersVisible = 0; 

        /**
         * Parsea el roster (sin cambios funcionales)
         */
        async function parseRoster() {
            try {
                const response = await fetch(ROSTER_FILE_NAME);
                if (!response.ok) throw new Error(`Error al cargar el archivo: ${response.statusText}`);
                const htmlText = await response.text();
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlText, 'text/html');
                const parsedRoster = {};
                const categoryHeadings = doc.querySelectorAll('h3');

                categoryHeadings.forEach(h3 => {
                    const h3Text = h3.textContent || '';
                    if (h3Text.includes('Categoría')) {
                        const categoryName = h3Text.split('--')[0].trim();
                        const players = [];
                        let nextEl = h3.nextElementSibling;
                        while (nextEl) {
                            if (nextEl.classList.contains('players_table')) break;
                            nextEl = nextEl.nextElementSibling;
                        }
                        if (nextEl) {
                            const rows = nextEl.querySelectorAll('tbody tr');
                            rows.forEach(row => {
                                const nameCell = row.querySelector('td:nth-child(2)');
                                if (nameCell) players.push(nameCell.textContent.trim());
                            });
                        }
                        if (players.length > 0) parsedRoster[categoryName] = players;
                    }
                });
                return parsedRoster;
            } catch (error) {
                console.error("Error en parseRoster:", error);
                categoryEl.textContent = 'Error';
                playerListEl.innerHTML = '<li>No se pudo cargar el archivo del roster.</li>';
                return null;
            }
        }

        /**
         * Carga la lista de jugadores para una categoría específica (sin cambios funcionales)
         */
        function buildCategoryList(categoryName) {
            const players = allPlayersData[categoryName];
            
            let html = '';
            players.forEach(name => {
                html += `<li>${name}</li>`;
            });
            playerListEl.innerHTML = html;
            categoryEl.textContent = categoryName;
        }

        /**
         * Aplica los filtros de búsqueda y categoría a la lista de jugadores.
         */
        function applyFilters() {
            const searchTerm = searchInputEl.value.toLowerCase();
            const selectedCategory = categoryFilterEl.value;

            // Si la categoría seleccionada es "Todas las categorías", mostramos todos los jugadores
            // De lo contrario, solo los de la categoría seleccionada
            if (selectedCategory === "all") {
                // Reconstruir la lista con todos los jugadores de todas las categorías
                let allHtml = '';
                categoryKeys.forEach(catName => {
                    allPlayersData[catName].forEach(name => {
                        allHtml += `<li>${name} (${catName})</li>`; // Opcional: añadir categoría al lado del nombre
                    });
                });
                playerListEl.innerHTML = allHtml;
                categoryEl.textContent = "Todas las Categorías";
            } else {
                buildCategoryList(selectedCategory);
            }

            const players = playerListEl.querySelectorAll('li');
            players.forEach(playerLi => {
                const playerName = playerLi.textContent.toLowerCase();
                if (playerName.includes(searchTerm)) {
                    playerLi.style.display = '';
                } else {
                    playerLi.style.display = 'none';
                }
            });
        }

        /**
         * Función principal de inicialización
         */
        async function main() {
            allPlayersData = await parseRoster();
            if (!allPlayersData) return;

            categoryKeys = Object.keys(allPlayersData);
            if (categoryKeys.length === 0) {
                categoryEl.textContent = 'Roster Vacío';
                return;
            }

            // Poblar el selector de categorías
            let categoryOptionsHtml = '<option value="all">Todas las Categorías</option>';
            categoryKeys.forEach(key => {
                categoryOptionsHtml += `<option value="${key}">${key}</option>`;
            });
            categoryFilterEl.innerHTML = categoryOptionsHtml;

            // Cargar la primera categoría o todas inicialmente
            buildCategoryList(categoryKeys[0]);

            // Event listeners para los filtros
            categoryFilterEl.addEventListener('change', () => applyFilters());
            searchInputEl.addEventListener('keyup', () => applyFilters());
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>